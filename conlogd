#!/bin/bash
############################################################
#    Console Server and Logger for IPMI and KVM based on tmux
#    Copyright (C) 2013  Alex Owen <r.alex.owen@gmail.com>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License along
#    with this program; if not, write to the Free Software Foundation, Inc.,
#    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
############################################################
# 2013-08-26 - Improved configuration 

#Functions needed for loading config

parse_uri() {
#From IEFT STD66: URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
#Now here is a parser:

uri="$@"
#escape some dangerious characters
uri="${uri//\`/%60}"
uri="${uri//\"/%22}"

#Parse the general syntax
pattern='^([a-z][a-z0-9+\.-]*):([^?#]*)(\?[^#]*)?(#.*)?$'
[[ "$uri" =~ $pattern ]] || return 1;
URI_scheme=${BASH_REMATCH[1]}
URI_hier_part=${BASH_REMATCH[2]}
URI_query=${BASH_REMATCH[3]}
URI_fragment=${BASH_REMATCH[4]}

#Parse the hier-part
pattern='(^//([^/]*))?(.*)'
[[ "$URI_hier_part" =~ $pattern ]] || return 1;
URI_authority=${BASH_REMATCH[2]}
URI_path=${BASH_REMATCH[3]}

unset URI_userinfo
unset URI_host
unset URI_port
unset URI_username
unset URI_password

if [ -n "$URI_authority" ] ; then
    #parse the authority
    #pattern='((.*)@)?(.*)'
    pattern='((.*)@)?([^:]*)(:([0-9]*))?'
    [[ "$URI_authority" =~ $pattern ]] || return 1;
    URI_userinfo=${BASH_REMATCH[2]}
    URI_host=${BASH_REMATCH[3]}
    URI_port=${BASH_REMATCH[5]}
    if [ -n "$URI_userinfo" ] ; then
        #parse the userinfo
        pattern='([^:]*)(:(.*))?'
        [[ "$URI_userinfo" =~ $pattern ]] || return 1;
        URI_username=${BASH_REMATCH[1]}
        URI_password=${BASH_REMATCH[3]}
    fi
fi
}



declare -A CL_type
declare -A CL_host
declare -A CL_password
declare -A CL_user

conlog(){ 
#$1=hostname $2=URI
parse_uri "$2"
CL_type[$1]=$URI_scheme
CL_host[$1]=$URI_host
CL_user[$1]=$URI_username
CL_password[$1]=$URI_password

#parse config file into arrays
}

#for name in "${!CL_host[@]}" ; do echo $name ${CL_host[$name]} ; done

########################
###example config file
########################
## NB: This is a bash script fragment which is sourced.
##     Take care when using what bash thinks are special characters!
##
## If you don't have DNS for ipmi clients but a formular/mapping from regular DNS 
## then implememt a genip function for example:
#genip(){ #$1=hostname
#if host $1 >/dev/null 2>&1 ; then 
#	echo 192.168.$(host $1 | sed -e's/.*has address [1-9]*\.[1-9]*\.//')
#else
#	return 1
#fi
#}
## Now define hosts
## IPMI host with generated/mapped IP 
#conlog batman "ipmi://user:pass@$(genip batman)"
## IPMI host with dns entry for bmc
#conlog robin "ipmi://user:pass@robin.ipmi.my.net"
## Local KVM host
#conlog zoro  "qemu:///system"
## Remote KVM host - conlog user needs ssh keys in place 
#conlog test  "qemu+ssh://root@kvmhost.company.org/system"
########################



#Default Variables

ALT_CLIENT_NAME=ipmiconsole
CONLOGDSOCKET=/tmp/conlogd-socket
GROUP=staff
#Default vars restartsol
NORMALRESTARTPAUSE=4
MINELAPSED=20
GOODRUNTIME=$(( 12 * 60 * 60 )) # 12 hours

#load system config
[ -r /etc/conlogd.conf ] && . /etc/conlogd.conf
#load user config
[ -r ~/.conlogd.conf ] && . ~/.conlogd.conf

#Derivative variables
TMUX="tmux -S $CONLOGDSOCKET"

#Functions

do_stop(){ 
$TMUX kill-server 
}

do_status(){ 
$TMUX list-session 
}

start_ipmi_session(){ #$1=HOST
    HOST="$1"
    $TMUX new-session -d -s \[$HOST\] -n $HOST "$0 --internal-ipmi-console ${HOST} ${CL_host[$HOST]}"
    $TMUX set-option  status-left-length 18 >/dev/null 2>&1 
    $TMUX unbind-key c
    $TMUX unbind-key :
    $TMUX pipe-pane  "exec logger -t ConLog:$HOST "
    $TMUX new-window -n $HOST-menu "$0 --internal-ipmi-menu ${HOST} ${CL_host[$HOST]}"
    $TMUX previous-window
}

start_session(){ #$1=HOST
    HOST="$1"
    if [ "${CL_type[$HOST]}" = "ipmi" ] ; then
	start_ipmi_session $HOST
    elif [ "${CL_type[$HOST]}" = "qemu" ]; then 
	echo NOT IMPLEMENTED
	return 1
    fi
}

do_start(){
for HOST in "${!CL_host[@]}" ; do
    start_session "$HOST"
done
}



do_reload_kill_extra(){
#Kill old sessions
for HOST in $($TMUX list-session |sed -ne's%\[\([^]]*\).*%\1%p') ; do 
    [ ${CL_host[$HOST]} ] || $TMUX kill-session -t \[$HOST\] 
done
}

do_reload_start_missing(){
#Start new sessions
for HOST in "${!CL_host[@]}" ; do
    if ( $TMUX has-session -t \[$HOST\] 1>/dev/null 2>&1 ) ; then
	:
    else 
	start_session "$HOST"
    fi
done
}

do_reload_auto(){
do_reload_kill_extra
do_reload_start_missing
}

do_reload(){ #$1=HOST
HOST="$1"
$TMUX kill-session -t \[$HOST\]
do_reload_start_missing
}

log(){
	date -Is
	echo "$(basename $0): $@"
	logger -t $(basename $0) "$@"
}

p_status () {
log "Getting Power Status for $HOST"
ipmitool -f  <(echo ${CL_password[$HOST]}) -I lanplus -U ${CL_user[$HOST]} -H $IP chassis power status
}

p_on () {
log "Setting Power Status for $HOST to ON"
ipmitool -f  <(echo ${CL_password[$HOST]}) -I lanplus -U ${CL_user[$HOST]} -H $IP chassis power on
}

p_soft () {
log "Setting Power Status for $HOST to OFF(soft)"
ipmitool -f  <(echo ${CL_password[$HOST]}) -I lanplus -U ${CL_user[$HOST]} -H $IP chassis power soft
}

p_hard () {
log "Setting Power Status for $HOST to OFF(hard)"
ipmitool -f  <(echo ${CL_password[$HOST]}) -I lanplus -U ${CL_user[$HOST]} -H $IP chassis power off
}

b_pxe () {
log "Setting Next Boot of $HOST to PXE Boot"
ipmitool -f  <(echo ${CL_password[$HOST]}) -I lanplus -U ${CL_user[$HOST]} -H $IP chassis bootdev pxe
}
b_disk () {
log "Setting Next Boot of $HOST to Disk Boot"
ipmitool -f  <(echo ${CL_password[$HOST]}) -I lanplus -U ${CL_user[$HOST]} -H $IP chassis bootdev disk
}
b_bios () {
log "Setting Next Boot of $HOST to BIOS Setup"
ipmitool -f  <(echo ${CL_password[$HOST]}) -I lanplus -U ${CL_user[$HOST]} -H $IP chassis bootdev bios
}

bmc_warm(){
log "Warm Reset of BMC on $HOST"
ipmitool -f  <(echo ${CL_password[$HOST]}) -I lanplus -U ${CL_user[$HOST]} -H $IP mc reset warm
}

bmc_cold(){
log "Cold Reset of BMC on $HOST"
ipmitool -f  <(echo ${CL_password[$HOST]}) -I lanplus -U ${CL_user[$HOST]} -H $IP mc reset cold
}

t_reset(){
reset
}



conlogdmenu(){
HOST=$1
IP=$2

trap ":" SIGINT

reset #Clear screen and reset terminal
while :
do
echo 
echo "------------------------------------------------------------"
echo " $HOST IPMI/Power Menu        NB: ^B-p to return to SOL"
echo "------------------------------------------------------------"
#### "    5    |    5    |    5    |    5    |    5    |    5    |"
echo "1. Power Status              6. Next Boot -> Network"
echo "2. Power On                  7. Next Boot -> Disk"
echo "3. Power Off (soft)          8. Next Boot -> BIOS Setup"
echo "4. FORCE Power Off           9. Reset BMC (Warm)echo "
echo "5. Reset Terminal           10. Reset BMC (Cold)" 
echo "------------------------------------------------------------"
echo -n "Your choice? : "
read choice
echo
echo
case $choice in
1) p_status ;;
2) p_on ;;
3) p_soft ;;
4) p_hard ;;
5) t_reset ;;
6) b_pxe ;;
7) b_disk ;;
8) b_bios ;;
9) bmc_warm ;;
10) bmc_cold ;;
*) echo "\"$choice\" is not valid" ; sleep 2 ;;
esac
echo
done
}





conlogdrestartsol(){

HOST=$1
if [ -z "$2" ]; then 
	log "PROBLEM STARTING AS NO IP ADDRESS GIVEN"
	exit 1
fi
IP=$2


# trap keyboard interrupt (control-c) and do nothing!
trap ":" SIGINT 

i=0
while true ; do	
    ipmitool -f  <(echo ${CL_password[$HOST]}) -I lanplus -U ${CL_user[$HOST]} -H $IP sol deactivate
    sleep 1
    reset
    log "Starting ipmi console on $HOST"
    STARTTIME=$SECONDS
    ipmitool -f  <(echo ${CL_password[$HOST]}) -I lanplus -U ${CL_user[$HOST]} -H $IP sol activate
    EXITCODE=$?
    ENDTIME=$SECONDS
    i=$(( $i + 1 ))
    
    if [ $EXITCODE  -eq 0 ] ; then
	#normal exit so restart after a brief pause
	log "Normal Restart"
	i=0
	sleep $NORMALRESTARTPAUSE 
	continue	
    fi
    #If we get here then we had an error exit code.
    elapsed=$(( $ENDTIME - $STARTTIME  ))
    
    if [ $elapsed -gt $GOODRUNTIME ] ; then
	#ignore the error and restart
	log "Good Restart"
	i=0
        sleep $NORMALRESTARTPAUSE
        continue
    fi
    
    
    if [ $i -lt 10 ] ; then
	THISWAIT=20
    elif [ $i -lt 70 ] ; then
	# i is between 10 and 70
	if [ $elapsed -lt $MINELAPSED ] ; then
	    log "We have a problem as runtime too short and already restarted 9 times (3mins)"
	    break
        fi
	THISWAIT=60
    else
	log "Restarting over 70 times (1hour)...  so problem"
	break
    fi
    log "Restart number $i in $THISWAIT seconds"
    sleep $THISWAIT
    continue
done

log "ERROR: terminating!"
exit 1
}

###
tmux_session_users(){ #$1=host
session="\[$1\]"
stat -c%U $($TMUX list-clients | sed -n "/${session}/s/\:.*//p") 2>/dev/null
}

formatusers(){ #$1=extra_user
( [ -n "$1" ]&& echo "$1" 
tmux_session_users "$host" ) |sort -u | tr \\n  ' '
}


console-client-exit(){ #$1=host"
    host="$1"
    $TMUX set-option -t \[$host\]  status-right "$(formatusers)" >/dev/null
    logger -t conlog "DETACH user=$USER from $host" 
}

console-client(){
host="$1"
if ( $TMUX has-session -t "\[$host\]" 1>/dev/null 2>&1 ) ; then 
    logger -t conlog "ATTACH user=$USER to $host" 
    $TMUX set-option -t \[$host\]  status-right "$(formatusers $USER)" >/dev/null
    trap "console-client-exit $host" EXIT
    $TMUX attach-session -t \[$host\]
else
    echo
    echo ERROR: no such session - \[$host\]
    echo
    echo Available Sessions:
    $TMUX list-sessions
    echo
    echo This program will terminate in 5 seconds
    sleep 5
    return 1
fi
}
###


#main()

if [ "$(basename $0)" = "conlog" -o  "$(basename $0)" = "$ALT_CLIENT_NAME" ] ; then
    console-client "$@"
    exit $?
fi

#Get us running as correct group
group=$(id -gn)
if [ "$group" != "$GROUP" ]; then
 exec sg $GROUP -c "$0 $*"
fi 

case "$1" in 
start)
	do_start 
	;;
stop)
	do_stop
	;;
restart)
	do_stop
	do_start
	;;
status)
	do_status
	;;
reload)
	if [ "$2" ] ; then 
		do_reload "$2"
	else
		do_reload_auto
	fi
	;;
--internal-ipmi-menu)
	conlogdmenu "$2" "$3"
	;;
--internal-ipmi-console)
	conlogdrestartsol "$2" "$3"
	;;
*)
	echo UNKNOWN ARGUMENT
	exit 1
	;;
esac


